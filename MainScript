################################################################
# MAIN SCRIPT - DNA metabarcoding processing pipeline
################################################################

# COI TEST MAIN
# Nov 29, 2025
# R version 4.5

################################################################
# (1) PACKAGE MANAGEMENT
################################################################

# Load necessary libraries
cran_packages <- c(
  "here", "ggplot2", "tibble", "dplyr", "usethis", "Rcpp", "devtools", "remotes", "ape", "phangorn", "tidyverse"
)
bioc_packages <- c(
  "dada2", "phyloseq", "speedyseq", "decontam", "metagMisc", "DECIPHER", "lulu", "rBLAST",
  "Biostrings", "BiocGenerics", "XVector", "GenomeInfoDb", "ShortRead", "RcppParallel"
)
github_packages <- list(
  metagMisc = "vmikk/metagMisc",
  lulu = "tobiasgf/lulu",
  speedyseq = "mikemc/speedyseq"
)

# Install CRAN packages
to_install_cran <- setdiff(cran_packages, rownames(installed.packages()))
if(length(to_install_cran)) install.packages(to_install_cran)

# Install Bioconductor packages
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
to_install_bioc <- setdiff(bioc_packages, rownames(installed.packages()))
if(length(to_install_bioc)) BiocManager::install(to_install_bioc, ask = FALSE, update = FALSE)

# Install GitHub packages if not present
if (!requireNamespace("remotes", quietly = TRUE)) install.packages("remotes")
for(pkg in names(github_packages)) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    remotes::install_github(github_packages[[pkg]])
  }
}

# Load all packages
all_packages <- unique(c(cran_packages, bioc_packages, names(github_packages)))
invisible(lapply(all_packages, function(pkg) library(pkg, character.only = TRUE)))


################################################################
# (2) USER CONFIGURATION - SET ALL PARAMETERS HERE
################################################################

# --- Project & File Settings ---
project_id    <- "testCOI"
primer        <- "COI"
metadata_file <- "metadata_unique.csv"
tax_db        <- "MIDORI2_UNIQ_NUC_GB267_CO1_DADA2.fasta"

# --- DADA2 Parameters (Review after Step A) ---
trunc_params <- list(
  truncLen = c(225, 215),  # Forward and Reverse read truncation length
  maxEE = c(2, 2),         # Max expected errors
  truncQ = 2               # Truncate at first quality score < this value
)
COI_seqtab <- TRUE # TRUE to filter seq table by length 310â€“316 bp for COI
NOVA_seq   <- TRUE # TRUE if data is from NovaSeq (to handle binned quality scores)

# --- Decontamination Parameters ---
decon_min_reads   <- 300   # Min reads for a sample to be considered in prevalence check
decon_max_n_ratio <- 0.001 # Max ratio of 'N' bases allowed in a sequence (stricter for COI)

# --- BLAST & LCA Parameters (for HPC/SLURM) ---
blast_account     <- "your_account_name"      # SLURM account name
blast_email       <- "your_email@domain.com"  # Email for job notifications
blast_time        <- "01:00:00"               # Job run time (HH:MM:SS)
blast_cpus        <- 10                       # Number of CPUs (must match threads)
blast_mem         <- "4G"                     # Memory allocation (e.g., 4G, 8G)
blast_db_name     <- "MIDORI2_UNIQ_NUC_GB267_CO1_BLAST" # Name of pre-formatted BLAST db on cluster
blast_evalue      <- 1e-5                     # E-value cutoff for BLAST search
lca_tid           <- 97                       # Taxonomy ID threshold for LCA
lca_tcov          <- 90                       # Taxonomy coverage threshold for LCA


################################################################
# (3) AUTOMATED SETUP - DO NOT EDIT BELOW THIS LINE
################################################################

# --- Define Directory and File Paths ---
# Core directories
input_root   <- here("eDNA", "inputs")
scripts_root <- here("eDNA", "scripts")
output_root  <- here("eDNA", "outputs", project_id)
figures_root <- here("eDNA", "figures", project_id)
tax_root     <- here("eDNA", "tax", tax_db)

# Input paths
metadata_path <- here(input_root, "metadata", metadata_file)
trimmed_path  <- here(input_root, "trimmed", project_id, primer)

# Output paths
dada2_output            <- here(output_root, paste0(project_id, "_dada2.rds"))
track_table_path        <- here(output_root, paste0(project_id, "_read_changes.txt"))
nochim_output           <- here(output_root, paste0(project_id, "_nochim_transposed.rds"))
nochim_csv              <- here(output_root, paste0(project_id, "_nochim.csv"))
tax_table_path          <- here(output_root, paste0(project_id, "_taxtable.rds"))
phyloseq_path           <- here(output_root, paste0(project_id, "_phyloseq.rds"))
asv_seqs_path           <- here(output_root, paste0(project_id, "_ASV_sequences.rds"))
asv_fasta_path          <- here(output_root, paste0(project_id, "_ASV_sequences.fasta"))
clustered_phyloseq_path <- here(output_root, paste0(project_id, "_clustered_phyloseq.rds"))
vsearch_fasta_path      <- here(output_root, paste0(project_id, "_otus.fasta"))
vsearch_output_path     <- file.path(output_root, "match_list97.txt")
curated_phyloseq_path   <- here(output_root, paste0(project_id, "_lulu_curated.rds"))
curated_fasta_path      <- file.path(output_root, paste0(project_id, "_curated_otus.fasta"))
blast_output_path       <- here(output_root, "blast_top10_hits.tsv")
blast_template_path     <- here(scripts_root, "COI_E_Blast_template.sh")
final_blast_script_path <- here(output_root, "run_blast.sh")
lca_input_path          <- here(output_root, paste0(project_id, "_lca_input.txt"))
lca_output_path         <- here(output_root, paste0(project_id, "_lca_assigned_taxonomy.txt"))
final_phyloseq_path     <- here(output_root, paste0(project_id, "_final_phyloseq.rds"))

# --- Create Directories ---
dir.create(output_root, showWarnings = FALSE, recursive = TRUE)
dir.create(figures_root, showWarnings = FALSE, recursive = TRUE)


################################################################
# (4) PIPELINE EXECUTION
################################################################

## (A) INITIAL QUALITY ASSESSMENT ##
# Purpose: Generate quality plots to determine trimming parameters.
# Input:   Trimmed FASTQ files from `trimmed_path`.
# Output:  Quality plot PNGs in the figures directory.
source(file.path(scripts_root, "A_Quality_Assessment.R"))
quality_data <- generate_quality_plots(pathinput = trimmed_path, pathfigures = figures_root)
message("Quality plots generated. Please review them in the '", figures_root, "' directory to set 'trunc_params' in section (2).")


## (B) INFER ASVs WITH DADA2 ##
# Purpose: Filter, trim, and infer ASVs from sequence reads.
# Input:   Raw sequence files and `trunc_params`.
# Output:  ASV table (`seqtab_nochim`).
source(file.path(scripts_root, "B_Infer_ASVs_DADA2.R"))
dada2_results <- run_dada2_processing(
  fnFs = quality_data$fnFs,
  fnRs = quality_data$fnRs,
  pathinput = trimmed_path,
  pathoutput_tracktable = track_table_path,
  pathfigures = figures_root,
  trunc_params = trunc_params,
  ncores = 8,
  use_nova_seq = NOVA_seq,
  use_coi_seqtab = COI_seqtab
)
seqtab_nochim <- dada2_results$seqtab_nochim
saveRDS(seqtab_nochim, nochim_output) # Save the key output


## (C) INITIAL TAXONOMY ASSIGNMENT (DADA2) ##
# Purpose: Assign taxonomy for preliminary analysis and decontamination.
# Input:   ASV table (`seqtab_nochim`).
# Output:  Taxonomy table.
source(file.path(scripts_root, "C_Assign_Taxonomy_DADA2.R"))
tax_table <- assign_taxonomy(
  seqtab_nochim = seqtab_nochim,
  tax_db_path = tax_root,
  output_path = tax_table_path,
  ncores = 8,
  seed = 119
)


## (D) CREATE INITIAL PHYLOSEQ OBJECT ##
# Purpose: Combine ASV table, taxonomy, and metadata into a phyloseq object.
# Input:   ASV table, taxonomy table, metadata.
# Output:  Initial phyloseq object (`ps_initial`).
source(file.path(scripts_root, "D_Phyloseq.R"))
ps_initial <- create_phyloseq(
  otu_table = seqtab_nochim,
  tax_table = tax_table,
  metadata_path = metadata_path,
  output_path = phyloseq_path
)


################################################################
# (5) MARKER-SPECIFIC STEPS: COI
################################################################

## (COI-A) DECONTAMINATION ##
# Purpose: Remove contaminant sequences using decontam.
# Input:   Initial phyloseq object.
# Output:  Cleaned phyloseq object (`ps_clean`).
source(file.path(scripts_root, "COI_A_Decontam.R"))
decon_results <- run_COI_decontamination(
  physeq = ps_initial,
  output_dir = output_root,
  project_id = project_id,
  control_col = "sample_type",
  neg_controls = c("extraction control", "field control", "pcr control"),
  min_reads = decon_min_reads,
  max_n_ratio = decon_max_n_ratio
)
ps_clean <- decon_results$phyloseq_clean


## (COI-B) CLUSTER ASVs (DECIPHER) ##
# Purpose: Cluster similar ASVs into OTUs (97% similarity).
# Input:   Cleaned phyloseq object.
# Output:  OTU-clustered phyloseq object (`ps_otu`).
source(file.path(scripts_root, "COI_B_Cluster_ASVs.R"))
ps_otu <- cluster_coi_asvs(
  ps_object = ps_clean,
  output_path = clustered_phyloseq_path,
  cutoff = 0.03 # 97% similarity
)


## (COI-C) PREPARE FOR VSEARCH & LULU ##
# Purpose: Create a FASTA file for VSEARCH.
# Input:   OTU-clustered phyloseq object.
# Output:  FASTA file of OTU representative sequences.
source(file.path(scripts_root, "COI_C_Vsearch_Prep.R"))
prepare_for_vsearch(ps_object = ps_otu, output_fasta_path = vsearch_fasta_path)
message("\nACTION REQUIRED: Run VSEARCH in your terminal.")
message("1. Navigate to the output directory: cd ", output_root)
message("2. Run the command: vsearch --usearch_global ", basename(vsearch_fasta_path), " --db ", basename(vsearch_fasta_path), " --self --id 0.84 --iddef 1 --userout ", basename(vsearch_output_path), " --userfields query+target+id --maxaccepts 0 --query_cov 0.9 --maxhits 10")


## (COI-D) CURATE OTUS WITH LULU ##
# Purpose: Remove erroneous OTUs based on co-occurrence.
# Input:   OTU-clustered phyloseq object and VSEARCH match list.
# Output:  Lulu-curated phyloseq object (`ps_curated`).
vsearch_matches <- read.table(vsearch_output_path, header = FALSE, col.names = c("OTUid", "hit", "match"))
source(file.path(scripts_root, "COI_D_Lulu_Curation.R"))
ps_curated <- curate_lulu(
  ps_object = ps_otu,
  matchlist_df = vsearch_matches,
  output_path = curated_phyloseq_path
)
Biostrings::writeXStringSet(refseq(ps_curated), filepath = curated_fasta_path)


## (COI-E) GENERATE BLAST SCRIPT ##
# Purpose: Create a SLURM script to run BLAST on an HPC.
# Input:   Curated OTU FASTA file and BLAST parameters.
# Output:  A `run_blast.sh` script in the output directory.
blast_script_template <- readLines(blast_template_path)
blast_script_configured <- gsub("__ACCOUNT_NAME__", blast_account, blast_script_template)
blast_script_configured <- gsub("__EMAIL__", blast_email, blast_script_configured)
blast_script_configured <- gsub("__TIME__", blast_time, blast_script_configured)
blast_script_configured <- gsub("__CPUS__", blast_cpus, blast_script_configured)
blast_script_configured <- gsub("__MEM__", blast_mem, blast_script_configured)
blast_script_configured <- gsub("__DB_NAME__", blast_db_name, blast_script_configured)
blast_script_configured <- gsub("__EVALUE__", blast_evalue, blast_script_configured)
blast_script_configured <- gsub("__QUERY_FILE__", curated_fasta_path, blast_script_configured)
blast_script_configured <- gsub("__OUTPUT_FILE__", blast_output_path, blast_script_configured)
writeLines(blast_script_configured, final_blast_script_path)
system(paste("chmod +x", final_blast_script_path))
message("\nACTION REQUIRED: Run BLAST on your HPC.")
message("1. Navigate to the output directory: cd ", output_root)
message("2. Submit the job: sbatch ", basename(final_blast_script_path))


## (COI-F) PREPARE FOR GALAXY-LCA ##
# Purpose: Format BLAST results for the galaxy-tool-lca script.
# Input:   BLAST output table.
# Output:  A formatted text file for the LCA tool.
source(file.path(scripts_root, "COI_F_GalaxyLCA.R"))
format_blast_for_lca(
  blast_output_path = blast_output_path,
  lca_input_path = lca_input_path,
  db_source_name = "MIDORI2_GB267"
)
message("\nACTION REQUIRED: Run galaxy-tool-lca in your terminal.")
message("1. Navigate to your galaxy-tool-lca directory.")
message("2. Run the command: python3 lca.py -i ", lca_input_path, " -o ", lca_output_path, " -b 8 -id 80 -cov 80 -t best_hits_range -tid ", lca_tid, " -tcov ", lca_tcov, " -flh unknown")


## (COI-G) CREATE FINAL PHYLOSEQ OBJECT ##
# Purpose: Combine curated OTU table with final LCA taxonomy.
# Input:   Lulu-curated phyloseq object and LCA taxonomy results.
# Output:  The final, analysis-ready phyloseq object.
source(file.path(scripts_root, "COI_G_FinalPhyloseq.R"))
ps_final <- create_final_phyloseq(
  lca_output_path = lca_output_path,
  curated_phyloseq_path = curated_phyloseq_path,
  final_phyloseq_path = final_phyloseq_path
)
message("\nPIPELINE COMPLETE! The final phyloseq object is saved at: ", final_phyloseq_path)

## 12S (MiFish) #########################################################
# (Future implementation)
